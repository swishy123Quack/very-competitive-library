\documentclass[8pt,a4paper,oneside,twocolumn]{extarticle} 

\usepackage[a4paper,margin=0.3in,includeheadfoot]{geometry}
\usepackage{graphicx}
\usepackage{amsmath} 
\usepackage{listings}
\usepackage{xcolor} 
\usepackage{xparse}
\usepackage{multicol}   
\usepackage{minted2}
\usepackage{fontawesome5}
\usepackage{fancyhdr}

\pagestyle{fancy}

\fancyhf{} 

\lhead{2mic1cup - University of Information and Technology}
\rhead{Topic - \nouppercase{\currentsectiontitle}}
\cfoot{\thepage}

\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}

\newcommand{\currentsectiontitle}{} 
\newcommand{\msection}[1]{\section{#1}\gdef\currentsectiontitle{#1}}

\NewDocumentCommand{\algorithm}{ m m o m m o }{
    \subsection{#1}
    \subsubsection*{\faBook\ Overview}
    \hrule
    \vspace{1em}
    {#2}
    \IfValueT{#3}{\subsubsection*{\faClock\ Time complexity: {#3}}}
    \subsubsection*{\faCode\ Implementation}
    \hrule
    \inputminted{#4}{#5}
    \IfValueT{#6}{
        \subsubsection*{\faQuestionCircle\ Usage}
        \hrule
        \vspace{1em}
        {#6}
    }
}

\usemintedstyle{gruvbox-light}
\definecolor{bgcol}{HTML}{F9F6D5}

\setlength{\columnsep}{0.3in}   

\title{
    \colorbox{yellow}{\textbf{Teamnote of 2mic1cup}} \\ \vspace{1em}
    \large swishy, lenhanbo, hungcubu \\ \vspace{1em}
    \large Last updated on \today \\ \vspace{1em}
    \includegraphics[width=0.2\textwidth]{buttadog.png} \vspace{1em}
    \hrule 
}

\date{}
\begin{document}

\maketitle
\tableofcontents
\newpage

\setminted{linenos, numbersep=5pt, numbers=left, stepnumber=1, framesep=2mm, bgcolor=bgcol, fontsize=\footnotesize, linenos, breaklines, breakanywhere}

\msection{Helpers}

\algorithm{Stress Tester}
{Simple .bat file for stress testing.}
{bat}{swishy/StressTester.bat}

\algorithm{Random}
{Self explanatory.}
{cpp}{swishy/Random.cpp}
[
\begin{itemize} 
    \item {$uid(a, b)$ returns random integer between $[a, b]$}
\end{itemize}
]

\algorithm{Hungbucu's amazing crazy diabolical template}
{Bro only contribution}
{cpp}{hungcubu/Template.cpp}


\msection{Data Structure}
\algorithm{Iterative Segment Tree}
{For-loop implementation of segment tree, faster than recursive. Note: Operation that depends on ordering is not supported (For example: Minimum prefix sum)}
[$\mathcal{O}(n)$ for constructor, $\mathcal{O}(\log n)$ for query]
{cpp}{swishy/SegmentTreeFast.cpp}

\algorithm{Lazy Segment Tree}
{Segment tree that supports ranged update.}
[$\mathcal{O}(n)$ for constructor, $\mathcal{O}(\log n)$ for query]
{cpp}{swishy/SegmentTreeLazy.cpp}

\algorithm{Sparse Table}{
    Uses binary lifting for efficient queries, offline only. 
}
[$\mathcal{O}(n\log n)$ for constructor, $\mathcal{O}(1)$ for query]
{cpp}{swishy/SparseTable.cpp}
[
    \begin{itemize}
        \item Init minimum range query and uses integer type \inputminted{cpp}{swishy/examples/SparseTable.cpp}
    \end{itemize}
]

\algorithm{Implicit Treap}{
    Implicit treap implementation with range add update and range sum query. push() and upd() functions should be changed accordingly like lazy segment tree.
}
[$\mathcal{O}(\log n)$ on average for all operations, large constant!!]
{cpp}{swishy/ImplicitTreap.cpp}

\algorithm{Dynamic Segment Tree}{
    Range queries and updates on larger range $(1 \leq l \leq r \leq 10^9)$
}
[$\mathcal{O}(\log M)$ for every operations, where $M$ is max range]
{cpp}{swishy/DynamicSegmentTree.cpp}

\algorithm{Persistent Segment Tree}{
    Preserving history for every segment tree updates.
}
[$\mathcal{O}(\log N)$ for every operations]
{cpp}{swishy/PersistentSegmentTree.cpp}
[
    \begin{itemize}
        \item Init and update segment tree with n nodes, each function returns a pointer, save if needed for later. \inputminted{cpp}{swishy/examples/PersistentSegmentTree1.cpp}
        \item Query the segment tree at a specific moment. \inputminted{cpp}{swishy/examples/PersistentSegmentTree2.cpp}
    \end{itemize}
]

\algorithm{2D Fenwick Tree}{
    Query and update on a 2D array.
}
[$\mathcal{O}(\log^2 n)$ for every operations]
{cpp}{swishy/2DFenwick.cpp}
[
    \begin{itemize}
        \item query(x, y) returns sum of value from $(1, 1)$ to $(x, y)$.
        \item query(x1, y1, x2, y2) returns sum of value from $(x1, y1)$ to $(x2, y2)$.
    \end{itemize}
]

\algorithm{Disjoint Set Union}{
    Union disjoint set lol.
}
[$\mathcal{O}(\alpha$(n))]
{cpp}{swishy/DissjointSet.cpp}

\algorithm{Line Container}{
    Add lines of the form $y=kx+m$, and query maximum value at point x.
}
[$\mathcal{O}(\log n)$]
{cpp}{swishy/LineContainer.cpp}

\algorithm{Lichao Tree}{
    Add lines of the form $y=ax+b$, and query maximum value at point x, segment tree implementation.
}
[$\mathcal{O}(\log n)$]
{cpp}{swishy/LichaoTree.cpp}

\algorithm{Ordered Set}{
    A set that supports finding k-th maximum value, or getting the order of an element.
}
[$\mathcal{O}(\log n)$, large constant]
{cpp}{swishy/OrderedSet.cpp}
[
    \begin{itemize}
        \item Uses just like a normal set, but with some added functions. \inputminted{cpp}{swishy/examples/OrderedSet.cpp}
    \end{itemize}
]

\algorithm{Minimum Stack/Deque}{
    Maintains minimum value in a stack/deque.
}
[$\mathcal{O}(\alpha$(n)), large constant]
{cpp}{swishy/MinimumDeque.cpp}

\algorithm{Dynamic Bitset}{
    Bitset with varied length support. NOTE: This requires relatively new version of GCC, and it might be BUGGED using the shift operator.
}
[$\mathcal{O}$(n / 32)]
{cpp}{swishy/DynamicBitset.cpp}
[
    \begin{itemize}
        \item Init a dynamic bitset with length n. \inputminted{cpp}{swishy/examples/DynamicBitset.cpp}
    \end{itemize}
]

\msection{Graph}

\algorithm{Graph}{
    Helper class, some implementations below will use this.
}
{cpp}{swishy/Graph.cpp}

\algorithm{Strongly Connected Components}{
    Find strongly connected components, compress the graph if needed
}
[$\mathcal{O}(N)$]
{cpp}{swishy/StronglyConnected.cpp}

\algorithm{Bridges and Articulations}{
    Find bridges and articulations!!
}
[$\mathcal{O}(N)$]  
{cpp}{swishy/BridgeArt.cpp}

\algorithm{Two SAT}{
    Solve a system of boolean formula, where every clause has exactly two literals.
}
[$\mathcal{O}(N + M)$, $M$ can be a slowing factor]
{cpp}{swishy/2SAT.cpp}
[
    \begin{itemize}
        \item The $add(x, a, y, b)$ function add the clause $(x$ OR $y)$, where $a, b$ signify whether $x$ or $y$ is negated or not.
        \item The $solve()$ function returns 1 if there exist a valid assignment, and 0 otherwise. The valid assignment will then be stored in $res$.
    \end{itemize}
]

\algorithm{MCMF}{
    Find a maximum flow with minimum cost, SPFA implementation.
}
[$\mathcal{O}(N^3)$ with a bullshit factor]
{cpp}{swishy/MCMF.cpp}

\algorithm{Maximum Flow (Dinic)}{
    Maximum flow using Dinic's algorithm.
}
[$\mathcal{O}(V^2E)$ for general graphs, but in practice $\approx \mathcal{O}(E^{1.5})$]
{cpp}{swishy/MaxFlow.cpp}

\algorithm{Maximum Matching (Hopcroft Karp)}{
    Find maximum matching on bipartite graph.
}
[$\mathcal{O}(m \sqrt{n})$ worst case]
{cpp}{swishy/HopcroftKarp.cpp}

\algorithm{General Matching (Blossom)}{
    Find maximum matching on general graph.
}
[$\mathcal{O}(n^3)$ worst case]
{cpp}{swishy/Blossom.cpp}

\msection{Math}

\algorithm{Modular Int}{
    Helper class, some implementations below will use this.
}
{cpp}{swishy/Modu.cpp}

\algorithm{Modular Square Root}{
    Operations on field \[ \langle u, v \rangle = u + v \sqrt{k} \mod p\]
}   
{cpp}{swishy/EX.cpp}

\algorithm{Discrete Log}{
    Given $a, b, m$, find any $x$ that satisfy \[ a^x = b\mod m \]
}
[$\mathcal{O}(N\log\log N$)]
{cpp}{swishy/DiscreteLog.cpp}

\algorithm{Primite Root}{
    Given $a, n$, find $g$ so that for any $a$ such that $gcd(a, n) = 1$, there exists $k$ such that \[g^k = a \mod n \]
}
[$\mathcal{O}(Ans \cdot \log \phi (n) \cdot \log n)$)]
{cpp}{swishy/PrimitiveRoot.cpp}

\algorithm{Euler's Totient Funnction}{
    Find $\phi(i)$ for $i$ from $1$ to $N$.
}
[$\mathcal{O}(N\log\log N$)]
{cpp}{swishy/Phi.cpp}

\algorithm{Chinese Remainder Theorem}{
    Given a system of congruences \[a=a_1\mod M_1, a=a_2\mod M_2, ...\] where $M_i$ might not be pairwise coprime, find any $a$ that satisfy it. 
}
[$\mathcal{O}(N\log \max(M_i)$)]
{cpp}{swishy/CRT.cpp}
[
    \begin{itemize}
        \item The $add(x, y)$ function add the condition $a=x\mod y$.
        \item If $a \neq -1$, the solution $a$ will satisfy $a=A\mod M$.
    \end{itemize}
]

\algorithm{Extended Euclidean}{
    Given $a, b$, find any $x, y$ that satisfy \[ax + by = gcd(a, b)\]
    Note that the function pass $x, y$ by reference and returns $gcd(a, b)$.
}
[$\mathcal{O}(\log n)$)]
{cpp}{swishy/ExtendedEuclidean.cpp}

\algorithm{Linear Diophantine}{
    Given $a, b, c$, find any $x, y$ that satisfy \[ ax+by=c \]
}
[$\mathcal{O}(\log n)$)]
{cpp}{swishy/LinearDiophantine.cpp}

\algorithm{Matrix}{
    Matrix helper class.
}
{cpp}{swishy/Matrix.cpp}

\algorithm{Miller Rabin Primality Test}{
    Deterministic implementation of Miller Rabin.
}
[Should be fast]
{cpp}{swishy/MillerRabin.cpp}

\algorithm{Fast Fourier Transform}{
    $multiplymod(A, B, M)$ returns C where \[ C[u]=\sum_{i=1}^{|A|} \sum_{j=1}^{|B|} A_i \cdot B_j \mod M \ (i+j=u)\]
}
[$\mathcal{O}(n\log n)$)]
{cpp}{swishy/FFT.cpp}

\algorithm{OR Convolution}{
    $convoluteor(A, B)$ returns C where \[ C[u]=\sum_{i=1}^{|A|} \sum_{j=1}^{|B|} A_i \cdot B_j \mod M \ (i | j=u)\]
}
[$\mathcal{O}(2^N \cdot N$)]
{cpp}{swishy/ORConvolution.cpp}

\algorithm{XOR Convolution}{
    idk lol.
}
{cpp}{lenhanbo/XORConvolution.cpp}

\msection{String}

\algorithm{Rolling Hash}{
    Rolling hash implementation, use multiple mod if necessary.
}
[$\mathcal{O}(N)$]
{cpp}{swishy/Hash.cpp}

\algorithm{Z-Function}{
    Return an array where the $i$-th element corresponds to the longest sub-string starting from $i$ that matches the prefix of $s$.
}
[$\mathcal{O}(N)$]
{cpp}{swishy/ZFunction.cpp}

\algorithm{Prefix Function}{
    Return an array where the $i$-th element corresponds to the longest sub-string ending at $i$ that matches the prefix of $s$.
}
[$\mathcal{O}(N)$]
{cpp}{swishy/PrefixFunction.cpp}

\algorithm{Manacher's Algorithm}{
    Return an array where the $i$-th element corresponds to the longest palindrome that has $i$ as the center, note that the algorithm only works for odd length palindrome, even can also be easily handled by inserting a dummy character in every even indicies.
}
[$\mathcal{O}(N)$]
{cpp}{swishy/Manacher.cpp}

\algorithm{Aho-Corasick}{
    Construct an automaton of \texttt{Trie} nodes, where $dp[i][c]$ is the next state of $i$ when adding character $c$. If no state exists, we repeatedly go through the next longest available suffix $j$ of $i$, and try to get $dp[j][c]$.
}
[$\mathcal{O}(M*K)$, where $M$ is the number of nodes in the \texttt{Trie}, and $K$ is the alphabet size]
{cpp}{swishy/AhoCorasick.cpp}

\msection{Tree}

\algorithm{Tree}{
    Helper class, some implementations below will use this.
}
{cpp}{swishy/Tree.cpp}

\algorithm{Lowest Common Ancestor}{
    Uses binary lifting to find the k-th parent of a node.
}
[$\mathcal{O}(n\log n)$ for build, $\mathcal{O}(\log n)$ for query]
{cpp}{swishy/LCA.cpp}

\algorithm{Heavy Light Decomposition}{
    Clean implementation of HLD, only uses 1 segment, $pos[u]$ is the position of $u$ on the segment. Change the query function if needed, for now it's just max query using a segment tree
}
[$\mathcal{O}(n\log n)$ for build, $\mathcal{O}(\log^2 n)$ for query]
{cpp}{swishy/HLD.cpp}

\algorithm{Centroid Decomposition}{
    Uses the centroid of a tree to decompose into smaller subtrees, each node will be recursively decomposed in $\mathcal{O}(log)$ times.
}
[$\mathcal{O}(n\log n)$]
{cpp}{swishy/Centroid.cpp}

\msection{Geometry (Kactl)}

\algorithm{Kactl template}{
    Kactl implementation sometimes use their own template, reference this for clarity.
}
{cpp}{kactl/Template.cpp}

\algorithm{Point}{
    Helper class, some implementations below will use this.
}
{cpp}{kactl/Point.cpp}

\algorithm{CCW}{
    \begin{itemize}
        \item Returns where $p$ is as seen from $s$ towards $e$. 1/0/-1 $\Leftrightarrow$ left/on line/right.
        \item If the optional argument $eps$ is given 0 is returned if $p$ is within distance $eps$ from the line.
    \end{itemize}
}
{cpp}{kactl/CCW.cpp}

\algorithm{Circle Intersection}{
    Computes the pair of points at which two circles intersect. Returns false in case of no intersection.
}
[$\mathcal{O}(1)$]
{cpp}{kactl/CircleIntersection.cpp}

\algorithm{Circle Line}{
    Finds the intersection between a circle and a line. Returns a vector of either 0, 1, or 2 intersection points.
}
[$\mathcal{O}(1)$]
{cpp}{kactl/CircleLine.cpp}

\algorithm{Circle Polygon}{
    Returns the area of the intersection of a circle with a ccw polygon.
}
[$\mathcal{O}(n)$]
{cpp}{kactl/CirclePolygon.cpp}

\algorithm{Circle Tagents}{
    \begin{itemize}
        \item Finds the external tangents of two circles, or internal if r2 is negated.
        \item Can return 0, 1, or 2 tangents -- 0 if one circle contains the other (or overlaps it, in the internal case, or if the circles are the same);
1 if the circles are tangent to each other (in which case .first = .second and the tangent line is perpendicular to the line between the centers).
        \item .first and .second give the tangency points at circle 1 and 2 respectively.
        \item To find the tangents of a circle with a point set r2 to 0.
    \end{itemize}
}
[$\mathcal{O}(1)$]
{cpp}{kactl/CircleTangents.cpp}

\algorithm{Closest pair of points}{
    Finds the closest pair of points.
}
[$\mathcal{O}(n \log n)$]
{cpp}{kactl/ClosestPair.cpp}

\algorithm{Convex Hull}{
    Returns a vector of the points of the convex hull in counter-clockwise order. Points on the edge of the hull between two other points are not considered part of the hull.
}
[$\mathcal{O}(n \log n)$]
{cpp}{kactl/ConvexHull.cpp}

\algorithm{Hull Diameter}{
    Returns the two points with max distance on a convex hull (ccw, no duplicate/collinear points).
}
[$\mathcal{O}(n)$]
{cpp}{kactl/HullDiameter.cpp}

\algorithm{Point inside Hull}{
    \begin{itemize}
        \item Determine whether a point t lies inside a convex hull (CCW order, with no collinear points). Returns true if point lies within the hull. If strict is true, points on the boundary aren't included.
        \item \textbf{NOTE:} Requires \textbf{7.12} and \textbf{7.2}.
    \end{itemize}
}
[$\mathcal{O}(\log n)$]
{cpp}{kactl/PointInsideHull.cpp}

\algorithm{Point on Segment}{
    Returns true iff p lies on the line segment from s to e. Use $segDist(s,e,p)<=epsilon$ instead when using $Point<double>$.
}
[$\mathcal{O}(1)$]
{cpp}{kactl/OnSegment.cpp}

\algorithm{Segment Distance}{
    Returns the shortest distance between point p and the line segment from point s to e.
}
[$\mathcal{O}(1)$]
{cpp}{kactl/OnSegment.cpp}

\algorithm{Segment Intersection}{
    \begin{itemize}
        \item If a unique intersection point between the line segments going from s1 to e1 and from s2 to e2 exists then it is returned.
        \item If no intersection point exists an empty vector is returned.
        \item If infinitely many exist a vector with 2 elements is returned, containing the endpoints of the common line segment.
        \item \textbf{NOTE:} Requires \textbf{7.12}.
    \end{itemize}
}
[$\mathcal{O}(1)$]
{cpp}{kactl/SegmentIntersection.cpp}

\algorithm{Line Distance}{
    \begin{itemize}
        \item Returns the signed distance between point p and the line containing points a and b.
        \item Positive value on left side and negative on right as seen from a towards b. a==b gives nan.
    \end{itemize}
}
[$\mathcal{O}(1)$]
{cpp}{kactl/LineDistance.cpp}

\algorithm{Line Intersection}{
    \begin{itemize}
        \item If a unique intersection point of the lines going through s1,e1 and s2,e2 exists \{1, point\} is returned.
        \item If no intersection point exists \{0, (0,0)\} is returned and if infinitely many exists \{-1, (0,0)\} is returned.
    \end{itemize}
}
[$\mathcal{O}(1)$]
{cpp}{kactl/LineIntersection.cpp}

\algorithm{Polygon Area}{
    Returns twice the signed area of a polygon.
}
[$\mathcal{O}(n)$]
{cpp}{kactl/PolygonArea.cpp}

\algorithm{Polygon Cut}{
    Returns a vector with the vertices of a polygon with everything to the left of the line going from s to e cut away.
}
[$\mathcal{O}(n)$]
{cpp}{kactl/PolygonCut.cpp}

\algorithm{Point inside Polygon}{
    \begin{itemize}
        \item Returns true if p lies within the polygon. If strict is true, it returns false for points on the boundary.
        \item \textbf{NOTE:} Requires \textbf{7.12} and \textbf{7.2}.
    \end{itemize}
}
[$\mathcal{O}(n)$]
{cpp}{kactl/InsidePolygon.cpp}

\algorithm{Manhattan MST}{
    Given N points, returns up to $4*N$ edges, which are guaranteed to contain a minimum spanning tree for the graph with edge weights $w(p, q) = |p.x - q.x| + |p.y - q.y|$. Edges are in the form (distance, src, dst). Use a standard MST algorithm on the result to find the final MST.
}
[$\mathcal{O}(n)$]
{cpp}{kactl/ManhattanMST.cpp}

\msection{Notes}

\subsection{Finding min cut}
To build a min cut, once you have finished finding the max flow, bfs from source one more time. Edges that connect reached vertex and unreached vertex is considered a cut.

\subsection{Finding minimum vertex cover on bipartite graph (Kőnig's theorem)}
    \begin{itemize}
        \item Size of maximum matching = Size of minimum vertex cover.
        \item To build, use flow to find the maximum matching, and bfs from source one more time. The minimum vertex cover is the set of all vertices in the left partition that were not visited, combined with all vertices in the right partition that were visited.
        \item The weighted version is the same, except the capacity of the edge from source/sink to a vertex is that vertex weight.
    \end{itemize}

\end{document} 